### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AttributeDefinition {
  choices: Json
  key: String!
  type: AttributeType!
}

input AttributeDefinitionWhereInput {
  AND: [AttributeDefinitionWhereInput!]
  choices: JsonNullableFilter
  id: IntFilter
  key: StringFilter
  memberAttributes: MemberAttributeListRelationFilter
  memberFormSectionAttribute: MemberFormSectionAttributeListRelationFilter
  NOT: [AttributeDefinitionWhereInput!]
  OR: [AttributeDefinitionWhereInput!]
  type: EnumAttributeTypeFilter
}

""""""
input AttributeInput {
  key: String
  value: Json
}

enum AttributeType {
  Boolean
  Date
  Email
  List
  Number
  Option
  String
  Time
  Timestamp
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

"""Date custom scalar type"""
scalar Date

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input EnumAttributeTypeFilter {
  equals: AttributeType
  in: [AttributeType!]
  not: NestedEnumAttributeTypeFilter
  notIn: [AttributeType!]
}

input EnumRelationshipTypeFilter {
  equals: RelationshipType
  in: [RelationshipType!]
  not: NestedEnumRelationshipTypeFilter
  notIn: [RelationshipType!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

"""Gender (M/F/N)"""
enum Gender {
  F
  M
  N
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

scalar Json

input JsonNullableFilter {
  equals: Json
  not: Json
}

type Member {
  attributes(after: MemberAttributeWhereUniqueInput, before: MemberAttributeWhereUniqueInput, first: Int, last: Int): [MemberAttribute!]!
  id: Int!
  owner: User!
  registrationDate: DateTime!
}

type MemberAttribute {
  createdDate: DateTime!
  definition: AttributeDefinition!
  member: Member!
  updatedDate: DateTime!
  value: Json
}

input MemberAttributeListRelationFilter {
  every: MemberAttributeWhereInput
  none: MemberAttributeWhereInput
  some: MemberAttributeWhereInput
}

input MemberAttributeWhereInput {
  AND: [MemberAttributeWhereInput!]
  attributeId: IntFilter
  createdDate: DateTimeFilter
  definition: AttributeDefinitionWhereInput
  member: MemberWhereInput
  memberId: IntFilter
  NOT: [MemberAttributeWhereInput!]
  OR: [MemberAttributeWhereInput!]
  updatedDate: DateTimeFilter
  value: JsonNullableFilter
}

input MemberAttributeWhereUniqueInput {
  memberId_attributeId: MemberIdAttributeIdCompoundUniqueInput
}

""""""
type MemberCategory {
  form(after: MemberCategoryFormSectionWhereUniqueInput, before: MemberCategoryFormSectionWhereUniqueInput, first: Int, last: Int): [MemberCategoryFormSection!]!
  key: String!
  pricelistItem(after: PricelistItemWhereUniqueInput, before: PricelistItemWhereUniqueInput, first: Int, last: Int, orderBy: [PricelistItemOrderByInput!], where: PricelistItemWhereInput): [PricelistItem!]!
  registrationCode: String
}

type MemberCategoryFormSection {
  category: MemberCategory!
  section: MemberFormSection!
  sortOrder: Int!
}

input MemberCategoryFormSectionListRelationFilter {
  every: MemberCategoryFormSectionWhereInput
  none: MemberCategoryFormSectionWhereInput
  some: MemberCategoryFormSectionWhereInput
}

input MemberCategoryFormSectionWhereInput {
  AND: [MemberCategoryFormSectionWhereInput!]
  category: MemberCategoryWhereInput
  memberCategoryId: IntFilter
  memberFormSectionId: IntFilter
  NOT: [MemberCategoryFormSectionWhereInput!]
  OR: [MemberCategoryFormSectionWhereInput!]
  section: MemberFormSectionWhereInput
  show_on_registration: BoolFilter
  sortOrder: IntFilter
}

input MemberCategoryFormSectionWhereUniqueInput {
  memberCategoryId_memberFormSectionId: MemberCategoryIdMemberFormSectionIdCompoundUniqueInput
}

input MemberCategoryIdMemberFormSectionIdCompoundUniqueInput {
  memberCategoryId: Int!
  memberFormSectionId: Int!
}

input MemberCategoryWhereInput {
  AND: [MemberCategoryWhereInput!]
  form: MemberCategoryFormSectionListRelationFilter
  id: IntFilter
  key: StringFilter
  NOT: [MemberCategoryWhereInput!]
  OR: [MemberCategoryWhereInput!]
  pricelistItem: PricelistItemListRelationFilter
  registrationCode: StringNullableFilter
}

""""""
type MemberFormSection {
  attribute(after: MemberFormSectionAttributeWhereUniqueInput, before: MemberFormSectionAttributeWhereUniqueInput, first: Int, last: Int): [MemberFormSectionAttribute!]!
  key: String!
}

type MemberFormSectionAttribute {
  definition: AttributeDefinition!
  mandatory: Boolean!
  section: MemberFormSection!
  sortOrder: Int!
}

input MemberFormSectionAttributeListRelationFilter {
  every: MemberFormSectionAttributeWhereInput
  none: MemberFormSectionAttributeWhereInput
  some: MemberFormSectionAttributeWhereInput
}

input MemberFormSectionAttributeWhereInput {
  AND: [MemberFormSectionAttributeWhereInput!]
  attributeDefinitionId: IntFilter
  definition: AttributeDefinitionWhereInput
  mandatory: BoolFilter
  memberFormSectionId: IntFilter
  NOT: [MemberFormSectionAttributeWhereInput!]
  OR: [MemberFormSectionAttributeWhereInput!]
  section: MemberFormSectionWhereInput
  sortOrder: IntFilter
}

input MemberFormSectionAttributeWhereUniqueInput {
  memberFormSectionId_attributeDefinitionId: MemberFormSectionIdAttributeDefinitionIdCompoundUniqueInput
}

input MemberFormSectionIdAttributeDefinitionIdCompoundUniqueInput {
  attributeDefinitionId: Int!
  memberFormSectionId: Int!
}

input MemberFormSectionWhereInput {
  AND: [MemberFormSectionWhereInput!]
  attribute: MemberFormSectionAttributeListRelationFilter
  form: MemberCategoryFormSectionListRelationFilter
  id: IntFilter
  key: StringFilter
  NOT: [MemberFormSectionWhereInput!]
  OR: [MemberFormSectionWhereInput!]
}

input MemberIdAttributeIdCompoundUniqueInput {
  attributeId: Int!
  memberId: Int!
}

"""A definition of a member"""
input MemberInput {
  attributes: [AttributeInput]
  category: String
  familyName: String
  gender: Gender
  givenName: String
  registrationDate: DateTime
}

input MemberListRelationFilter {
  every: MemberWhereInput
  none: MemberWhereInput
  some: MemberWhereInput
}

input MemberRelationshipListRelationFilter {
  every: MemberRelationshipWhereInput
  none: MemberRelationshipWhereInput
  some: MemberRelationshipWhereInput
}

input MemberRelationshipWhereInput {
  AND: [MemberRelationshipWhereInput!]
  member: MemberWhereInput
  memberId: IntFilter
  NOT: [MemberRelationshipWhereInput!]
  OR: [MemberRelationshipWhereInput!]
  relatedMember: MemberWhereInput
  relatedMemberId: IntFilter
  relationshipType: EnumRelationshipTypeFilter
}

input MemberWhereInput {
  AND: [MemberWhereInput!]
  attributes: MemberAttributeListRelationFilter
  id: IntFilter
  membersRelatedToMe: MemberRelationshipListRelationFilter
  NOT: [MemberWhereInput!]
  OR: [MemberWhereInput!]
  owner: UserWhereInput
  ownerUserId: IntFilter
  registrationDate: DateTimeFilter
  relatedMembers: MemberRelationshipListRelationFilter
  type: StringFilter
}

input MemberWhereUniqueInput {
  id: Int
}

type Mutation {
  """Add a new member to the register"""
  createMember(data: MemberInput!): Member

  """Create a new user"""
  signupUser(emailAddress: String!, externalId: String!, familyName: String, givenName: String): User

  """Update an existing member"""
  updateMember(data: MemberInput!, id: Int!): Member

  """Update user details and roles"""
  updateUserDetails(email: String!, familyName: String, givenName: String, id: Int!, roles: [String!]!): User
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumAttributeTypeFilter {
  equals: AttributeType
  in: [AttributeType!]
  not: NestedEnumAttributeTypeFilter
  notIn: [AttributeType!]
}

input NestedEnumRelationshipTypeFilter {
  equals: RelationshipType
  in: [RelationshipType!]
  not: NestedEnumRelationshipTypeFilter
  notIn: [RelationshipType!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type News {
  attributes(after: NewsAttributeWhereUniqueInput, before: NewsAttributeWhereUniqueInput, first: Int, last: Int): [NewsAttribute!]!
  body: String!
  comments(after: NewsCommentWhereUniqueInput, before: NewsCommentWhereUniqueInput, first: Int, last: Int): [NewsComment!]!
  createdDate: DateTime!
  id: Int!
  publishDate: DateTime!
  title: String!
}

type NewsAttribute {
  name: String!
  news: News!
  value: String
}

input NewsAttributeWhereUniqueInput {
  id: Int
}

type NewsComment {
  author: String
  body: String!
  news: News!
}

input NewsCommentWhereUniqueInput {
  id: Int
}

type PriceList {
  dateFrom: Date
  dateTo: Date
  price: Float!
  pricelistItem: PricelistItem!
}

type PricelistItem {
  """The current price of the item"""
  currentPrice: Float
  description: String!
  id: Int!
  includesMatchFees: Boolean
  maxAge: Int
  memberCategory: MemberCategory!
  minAge: Int!
  pricelist(after: PriceListWhereUniqueInput, before: PriceListWhereUniqueInput, first: Int, last: Int, orderBy: [PriceListOrderByInput!], where: PriceListWhereInput): [PriceList!]!
}

input PricelistItemIdDateFromDateToCompoundUniqueInput {
  dateFrom: DateTime!
  dateTo: DateTime!
  pricelistItemId: Int!
}

input PricelistItemListRelationFilter {
  every: PricelistItemWhereInput
  none: PricelistItemWhereInput
  some: PricelistItemWhereInput
}

input PricelistItemOrderByInput {
  categoryId: SortOrder
  description: SortOrder
  id: SortOrder
  includesMatchFees: SortOrder
  maxAge: SortOrder
  minAge: SortOrder
}

input PricelistItemWhereInput {
  AND: [PricelistItemWhereInput!]
  categoryId: IntFilter
  description: StringFilter
  id: IntFilter
  includesMatchFees: BoolNullableFilter
  maxAge: IntNullableFilter
  memberCategory: MemberCategoryWhereInput
  minAge: IntFilter
  NOT: [PricelistItemWhereInput!]
  OR: [PricelistItemWhereInput!]
  pricelist: PriceListListRelationFilter
}

input PricelistItemWhereUniqueInput {
  id: Int
}

input PriceListListRelationFilter {
  every: PriceListWhereInput
  none: PriceListWhereInput
  some: PriceListWhereInput
}

input PriceListOrderByInput {
  dateFrom: SortOrder
  dateTo: SortOrder
  price: SortOrder
  pricelistItemId: SortOrder
}

input PriceListWhereInput {
  AND: [PriceListWhereInput!]
  dateFrom: DateTimeFilter
  dateTo: DateTimeFilter
  NOT: [PriceListWhereInput!]
  OR: [PriceListWhereInput!]
  price: FloatFilter
  pricelistItem: PricelistItemWhereInput
  pricelistItemId: IntFilter
}

input PriceListWhereUniqueInput {
  pricelistItemId_dateFrom_dateTo: PricelistItemIdDateFromDateToCompoundUniqueInput
}

type Query {
  feed: [News]
  me: User
  members: [Member]
  membershipCategories(where: MemberCategoryWhereInput): [MemberCategory]
  userByEmail(emailAddress: String!): User
  userByExternalId(externalId: String!): User
}

enum QueryMode {
  default
  insensitive
}

enum RelationshipType {
  emergency
  owner
  parent
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type User {
  email: String!
  externalId: String
  familyName: String
  givenName: String
  id: Int!
  members(after: MemberWhereUniqueInput, before: MemberWhereUniqueInput, first: Int, last: Int): [Member!]!
  roles: Json!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  email: StringFilter
  externalId: StringNullableFilter
  familyName: StringNullableFilter
  givenName: StringNullableFilter
  id: IntFilter
  members: MemberListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
}
